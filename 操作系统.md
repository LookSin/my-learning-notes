# 1.基本概念

## 操作系统的作用

1. 系统资源的管理者
2. 用户和计算机硬件之间的接口
3. 对硬件机器的拓展

## 操作系统的体系结构

### 内核

内核是计算机配置的底层**软件**，是操作系统最基本、最核心的部分。

### 体系结构

- 大内核：主要功能模块，运行在核心态
- 微内核：只把最基本的功能保留在内核

## 处理器状态

- 用户态：CPU只能执行非特权指令
- 核心态：CPU既可以执行非特权、也可以执行特权指令

## 中断和异常

**中断的本质**：发生中断就意味着需要操作系统介入，开展管理工作。

**中断**可以使CPU从**用户态转为核心态**，使操作系统获得计算机的控制权。**核心态到用户态**的切换是通过执行一个**特权指令**。

中断分为外中断和内中断，只需看信号的来源是**CPU外部还是内部**。

内中断又称**异常**。

## 系统调用

系统调用可以理解为一种可供应用程序调用的特殊函数。系统调用会使处理器从用户态进入核心态。凡是与资源有关的操作，会直接影响其他进程的操作，这时候需要系统调用的操作。

过程：

传递系统调用参数->执行陷入指令(**用户态**)->执行系统调用相应服务程序(**核心态**)->返回应用程序

# 2.进程管理

## 进程与线程

### **基本概念**

程序段、数据段、PCB(进程控制块)三部分组成了进程实体。进程是一个动态的过程。

**进程**是进程实体的**运行过程**，是系统进行**资源分配和调度**的一个独立单位。

**线程**是一个基本的CPU执行单元，也是程序执行流的最小单位。

### 进程状态及转换

三种基本状态：

- 运行态：占有CPU，并在CPU上运行
- 就绪态：已经具备运行条件，但是没有空闲CPU，暂时不能运行
- 阻塞态：因等待某一事件而暂时不能运行

另外两种状态：

- 创建态：进程正在被创建，操作系统为进程分配资源、初始化PCB
- 终止态：进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB

![image-20221118210747522](C:\Users\52908\AppData\Roaming\Typora\typora-user-images\image-20221118210747522.png)

### 线程状态及转换

线程也有就绪、阻塞、运行三种基本状态

**切换：**

- 同一进程中的线程切换，不会引起进程切换
- 不同进程中的线程切换，会引起进程切换
- 切换同进程内的线程，系统开销很小
- 切换进程，系统开销较大

## CPU进程调度算法

### 先来先服务(FCFS)

**非抢占式**。等待越久的越优先得到服务。不会导致饥饿。对长作业有利，对短作业不利。

周转时间 = 完成时间 - 到达时间

带权周转时间 = 周转时间/运行时间

等待时间 = 周转时间 - 运行时间

### 短作业优先(SJF)

**非抢占式。**

每次调度时选择当前已到达且运行时间最短的作业/进程。

若不强调非抢占式，默认非抢占。

"最短的"平均等待时间、平均周转时间。会产生饥饿。

### 最短剩余时间(SRTN)

**抢占式的短作业优先。**

- **每当有进程加入**、就绪队列改变时就需要调度，如果新到达的进程剩余时间更短，则由新进程抢占处理机
- **进程完成时**也需要调度

### 高响应比优先(HRRN)

**非抢占式。**避免长作业饥饿。

响应比 = (等待时间 + 要求服务时间)/要求服务时间

- 等待时间相同，服务时间短的优先
- 服务时间相同，等待时间长的优先

### 时间片轮转(RR)

**抢占式。**用于进程调度。

**优点：**公平；响应快，常用于分时操作系统，更注重"响应时间"。

不会导致饥饿。

时间片不能太大，会增大进程响应时间；也不能太小，会花大量的时间来处理进程切换。

### **优先级调度**

**抢占式、非抢占式。**

优先数越大，优先级越高。适合实时操作系统。可能导致饥饿。

### 多级反馈队列

**抢占式。**

设置多级就绪队列，各级优先级从高到低，时间片从小到大。

会导致饥饿。

## 进程同步与互斥

### 信号量机制

信号量表示系统中某种资源的数量。

原语是一种特殊的程序段，执行只能**一气呵成，不可被中断**。

**整型信号量(重要)：**整数型的变量，表示系统中某种资源的数量。不满足"让权等待"，会发生"忙等"。

**记录型信号量：**P、V操作；block、wakeup原语

### 生产者-消费者模型

是一个互斥、同步的综合问题。

### 读者-写者问题

解决复杂的互斥问题。

核心思想在于设置了一个计数器 count 用来记录当前正在访问共享文件夹的读进程数。

### 哲学家进餐问题

关键在于解决进程死锁。每个进程都需要同时持有**两个临界资源**，因此就有"死锁"问题的隐患。

## 进程通讯机制

进程通信就是进程之间的信息交换。

- 共享存储
  - 要互斥地访问。
- 管道通信
  - 一个管道只能实现半双工通信
  - 写满时，不能再写。读空时，不能再读。
  - 没写满，不能读。没读空，不能写。
- 消息传递
  - 直接通信方式(消息直接挂到接收方的消息队列里)
  - 间接通信方式(消息先发到中间体(信箱))

## 死锁

### 产生的条件

各进程互相等待对方手里的资源，导致各进程都堵塞，无法向前推进的现象。

什么时候发生死锁？

对不可剥夺资源的不合理分配。

### 预防与避免

**静态策略：预防死锁**

只要任一条件不成立，死锁就不会发生

- 互斥条件
- 不剥夺条件
- 请求和保持条件
- 循环等待条件

**动态策略：避免死锁**

银行家算法

### 检测与恢复

**检测：**

- 数据结构：资源分配图
  - 两种节点(进程节点、资源节点)
  - 两种边(进程节点->资源节点、资源节点->进程节点)
- 死锁检测算法

死锁检测算法：依次消除与**不阻塞进程**(申请的资源数还足够的进程)相连的边，直到无边可消。

**恢复：**

- 资源剥夺法
- 撤销(终止)进程法
- 进程回退法

# 3.内存管理

## 基本概念

**内存**是用于存放数据的硬件。程序执行前**需要先放到内存中才能被CPU处理**。

**内存地址**从0开始，**每个地址对应一个存储单元**。

**内存管理：**

- 内存空间的分配与回收
- 内存空间的扩展
- 地址转换
- 内存保护

## 覆盖与交换

覆盖技术：将程序分为多个段。缺点：对用户不透明

- 固定区中的程序段在运行过程中不会调入调出
- 覆盖区中的程序段在运行过程中会根据需要调入调出

交换技术：进程在内存与磁盘间动态调度。内存紧张时，换出某些进程以腾出内存空间，再换入某些进程。磁盘分为文件区和对换区，换出的进程放在对换区。

## 内存分配与回收

### 连续内存分配

**连续分配**：为用户进程分配的必须是一个**连续的内存空间**。

**单一连续分配：**内存中只能有一道用户程序。

内存分为系统区和用户区。

优点：实现简单，不一定需要采取内存保护。

缺点：有内部碎片。

**内存碎片：**分配给某进程的内存区域中，如果有些部分没有用上，就是内存部碎片。

**分区**

- 固定分区分配：用户中心划分为若干个固定大小的分区。

- 动态分区分配：根据进程的大小动态地建立分区

  - 首次适应算法：空闲分区以地址递增的次序排列
  - 最佳适应算法：按容量递增次序链接。缺点：产生很多外部碎片
  - 最坏(最大)适应算法：按容量递减次序链接
  - 临近适应算法：空闲分区以地址递增的顺序排列，从上次查找结束的位置开始查找空闲分区链

  ![image-20221130175743278](C:\Users\52908\AppData\Roaming\Typora\typora-user-images\image-20221130175743278.png)

### 非连续内存分配

#### 分段存储管理

进程的地址空间：按照程序自身的**逻辑关系**划分成若干个段

内存分配规则：每个段在内存中占据**连续空间**，各段之间可以不相邻。会产生外部碎片。

分段系统的逻辑地址由段号和段内地址组成。为每个进程建立一张段映射表，简称**段表**。

![image-20221130201850159](C:\Users\52908\AppData\Roaming\Typora\typora-user-images\image-20221130201850159.png)

#### 分页存储管理

将内存空间分为一个个大小相等的分区，每个分区就是**页框**。

将用户进程的地址空间也分为与一个页框大小相等的一个个区域，称为**页或者页面**。

![image-20221201112350166](C:\Users\52908\AppData\Roaming\Typora\typora-user-images\image-20221201112350166.png)

#### 页表

页表记录**进程页面和实际存放的内存块之间的对应关系**。

进程的每一页对应一个页表项，每个页表项由页号和块号组成。

问题：页表必须连续存放；没有必要让整个页面连续存储。

#### 二级页表

![image-20221203140836962](C:\Users\52908\AppData\Roaming\Typora\typora-user-images\image-20221203140836962.png)

#### 段页式存储管理

一个进程会对应一个段表，但是一个进程可能会对应多个页表。

![image-20221204115353122](C:\Users\52908\AppData\Roaming\Typora\typora-user-images\image-20221204115353122.png)

### 虚拟内存(非连续内存分配)

#### 基本概念

**高速缓冲技术**的思想：将近期会频繁访问到的数据放到更高速的存储器中，暂时用不到的数据放在更低速存储器中。

**虚拟内存**：在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留到外存。在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存。

主要特征：多次性、对换性、虚拟性。

**虚拟内存技术**需要建立在**离散分配**的内存管理方式基础上。

#### 局部性原理

1. 时间局部性：现在访问的指令、数据在不久之后很可能会被再次访问。
2. 空间局部性：现在访问的内存单元周围的内存空间，很可能在不久之后会被访问。
3. 高速缓存技术：使用频繁的数据放到更高速的存储器中。

#### 实现

##### 请求分页存储管理

与基本分页存储管理的主要区别：

1. 当访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存
2. 将内存中暂时用不到的信息换出到内存

​	![image-20221206123247282](C:\Users\52908\AppData\Roaming\Typora\typora-user-images\image-20221206123247282.png)

#### 页面置换算法

##### 最佳置换算法(OPT，理想置换算法)

每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再被访问的页面，这样可以保证最低的缺页率。

**最佳置换算法无法实现。**

##### 先进先出置换算法(FIFO)

每次选择淘汰的页面是最早进入内存的页面。

只有FIFO算法会产生 **Belady 异常**(为进程分配的物理块数增大时，缺页次数不减反增的异常现象)，算法性能差。

##### 最近最久未使用的置换算法(LRU)

每次淘汰的页面是**最近最久**未使用的页面。在**逆向扫描**过程中最后一个出现的页号就是要淘汰的页面。

性能好，但是实现困难，花销很大。

##### 时钟置换算法(CLOCK)

又称最近未用算法(NRU)。

简单的 CLOCK 算法选择一个**淘汰页面**最多会经过两轮扫描。

##### 第二次机会算法(改进型的时钟置换算法)

选择一个淘汰页面最多会进行**四轮**扫描。

![image-20221207120441776](C:\Users\52908\AppData\Roaming\Typora\typora-user-images\image-20221207120441776.png)

![image-20221207120555332](C:\Users\52908\AppData\Roaming\Typora\typora-user-images\image-20221207120555332.png)
